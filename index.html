<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Optimized Smooth Christmas</title>
<link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000011;
        font-family: "Poppins", sans-serif;
        touch-action: none;
    }

    #text {
        position: absolute;
        top: 15%; 
        width: 100%;
        text-align: center;
        color: white;
        opacity: 0;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 1.0));
        animation: fadeIn 3s ease-in-out forwards;
        z-index: 10;
        pointer-events: none;
        font-family: 'Great Vibes', cursive;
        font-weight: normal;
        letter-spacing: 2px;
        font-size: clamp(50px, 12vw, 120px); 
        white-space: nowrap;
    }

    @keyframes fadeIn {
        0% { opacity: 0; transform: translateY(20px); }
        100% { opacity: 1; transform: translateY(0); }
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div id="text">Merry Christmas</div>

<script>
const canvas = document.getElementById("canvas");
// Alpha true để hỗ trợ các hiệu ứng trong suốt tốt hơn
const ctx = canvas.getContext("2d", { alpha: true }); 

let currentTreeHeight = 0;
let isMobile = false;

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = window.innerWidth;
    const displayHeight = window.innerHeight;

    canvas.width = displayWidth * dpr;
    canvas.height = displayHeight * dpr;

    canvas.style.width = displayWidth + 'px';
    canvas.style.height = displayHeight + 'px';

    ctx.scale(dpr, dpr);
    isMobile = displayWidth < 768;
}
resizeCanvas();

// ================================
// PARTICLE CLASS
// ================================
class Particle {
    constructor(x, y, size, color, alpha) {
        this.x = x; 
        this.y = y;
        this.size = size;
        this.baseSize = size; 
        this.color = color;
        this.alpha = alpha;
        this.baseAlpha = alpha; 
        this.rotation = Math.random() * Math.PI * 2;
        
        this.angle = Math.random() * Math.PI * 2;
        this.orbitRadius = 0;
        this.orbitSpeed = 0;
        this.yOffset = 0;
    }

    draw(ctx) {
        let currentAlpha = this.alpha;
        // Giảm tần suất tính toán lấp lánh để tối ưu
        if (this.baseAlpha > 0.6) {
             this.rotation += 0.05;
             currentAlpha *= (0.9 + 0.1 * Math.cos(this.rotation));
        }
        
        if (currentAlpha < 0.05) return;

        ctx.globalAlpha = Math.min(1, currentAlpha);
        ctx.fillStyle = this.color;
        
        ctx.beginPath();
        // Tối ưu: Hạt nhỏ dùng rect (vẽ nhanh hơn arc)
        if (this.size < 0.8) {
            ctx.rect(this.x, this.y, this.size, this.size);
        } else {
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}

function noise(x, y, time) {
    return Math.sin(x * 0.01 + time) * Math.cos(y * 0.01 + time * 0.5) * 0.5 + 0.5;
}

// ================================
// 1. HỆ THỐNG TUYẾT (Đã Tối Ưu: Nhỏ, Chậm, Ít hơn)
// ================================
const snowParticles = [];
function createOrbitSnow() {
    // [TỐI ƯU 1] Giảm mạnh số lượng hạt
    // Mobile: 1200 hạt (vẫn đủ đẹp trên màn nhỏ), PC: 5000
    const snowCount = isMobile ? 1200 : 5000; 
    snowParticles.length = 0;
    
    const w = window.innerWidth;
    const h = window.innerHeight;
    
    const minRadius = w * 0.3; 
    const maxRadius = w * 2.5;

    for(let i=0; i<snowCount; i++) {
        // [TỐI ƯU 2] Giảm kích thước hạt tuyết
        // Mobile: 0.5px -> 2.0px
        const sizeBase = isMobile ? (Math.random()*1.5 + 0.5) : (Math.random()*2.0 + 0.5);
        const alpha = Math.random()*0.4 + 0.5; 
        
        const p = new Particle(0,0, sizeBase, "rgba(255,255,255,0.9)", alpha);
        p.angle = Math.random() * Math.PI * 2; 
        
        p.orbitRadius = minRadius + Math.pow(Math.random(), 1.5) * (maxRadius - minRadius);
        p.yOffset = (Math.random() - 0.5) * h * 3.0; 
        
        const radiusRatio = (p.orbitRadius - minRadius) / (maxRadius - minRadius);
        
        // [TỐI ƯU 3] Giảm tốc độ quay (Chậm hơn 50% so với trước)
        // Tốc độ từ 0.002 đến 0.01
        p.orbitSpeed = 0.002 + (radiusRatio * 0.008) + Math.random() * 0.001;

        snowParticles.push(p);
    }
}

// ================================
// 2. HỆ THỐNG MẶT ĐẤT
// ================================
const groundInner = [];  
const groundMiddle = []; 
const groundOuter = [];  

function createGroundRing(array, count, minR, maxR, speed, sizeBase, alphaBase) {
    array.length = 0;
    const tryCount = count * 1.5; 
    const mobileSizeMultiplier = isMobile ? 1.5 : 1.0;

    for(let i=0; i<tryCount; i++) {
        const p = new Particle(0,0, 0, "", 0);
        p.angle = Math.random() * Math.PI * 2;

        const ridgeValue = Math.sin(p.angle * 0) + Math.sin(Math.random()*maxR * 0.1);
        const ratio = Math.random();
        p.orbitRadius = minR + ratio * (maxR - minR);
        
        const normalizedHeight = Math.sin(p.orbitRadius * (isMobile ? 0.2 : 0.12)); 
        const spawnProbability = (normalizedHeight + 1) / 2 * 0.8 + 0.2;

        if (Math.random() < spawnProbability) {
            const blueish = 220 + Math.random() * 35;
            p.color = `rgba(${blueish}, ${blueish}, 255, 1.0)`; 
            
            const brightnessFactor = (normalizedHeight + 1) / 2;
            p.baseAlpha = alphaBase * (0.6 + 0.4 * brightnessFactor); 
            p.baseSize = sizeBase * mobileSizeMultiplier * (0.6 + 0.4 * brightnessFactor);
            
            const randomness = (Math.random() - 0.5) * 10;
            p.yOffset = (normalizedHeight * 15) + randomness; 
            
            p.orbitSpeed = speed;
            array.push(p);
            if (array.length >= count) break;
        }
    }
}

function initGroundLayers() {
    // Đất quay rất chậm
    const baseSpeed = 0.002; 
    const w = window.innerWidth;
    const countScale = isMobile ? 0.6 : 1.0;

    createGroundRing(groundInner, 4000 * countScale, w*0.02, w*0.28, baseSpeed*1.2, 1.5, 0.8);
    createGroundRing(groundMiddle, 5000 * countScale, w*0.28, w*0.65, baseSpeed, 1.8, 0.6);
    createGroundRing(groundOuter, 6000 * countScale, w*0.65, w*1.5, baseSpeed*0.8, 2.5, 0.4);
}


// ================================
// 3. LOGIC TẠO CÂY
// ================================
function generateNaturalLayeredTree(cx, cy, baseColor, highlightColor) {
    const treeParticles = [];
    const w = window.innerWidth;
    const h = window.innerHeight;
    
    const heightRatio = isMobile ? 0.45 : 0.55;
    const treeHeight = h * heightRatio;
    currentTreeHeight = treeHeight;

    const maxBaseWidth = isMobile ? (w * 0.18) : 120; 
    const layers = 12; 
    const layerHeight = treeHeight / layers;
    
    // Giảm nhẹ số lượng hạt cây trên mobile
    const particleCount = isMobile ? 3500 : 8000; 
    let created = 0; let attempts = 0;
    
    while (created < particleCount && attempts < particleCount * 15) {
        attempts++;
        const relY = Math.random() * treeHeight;
        const normalizedY = relY / treeHeight;
        const progressInLayer = (relY % layerHeight) / layerHeight;
        
        const layerFlare = 1 + 0.8 * Math.pow((1 - progressInLayer), 1.5);
        const coneWidth = maxBaseWidth * (1 - normalizedY);
        const maxWidthAtY = coneWidth * layerFlare;
        
        const randomPos = Math.random(); 
        const offsetX = (randomPos * maxWidthAtY) * (Math.random() > 0.5 ? 1 : -1);
        
        if (Math.abs(offsetX) <= maxWidthAtY) {
            const y = cy - relY;
            const distFromCenter = Math.abs(offsetX) / maxWidthAtY;
            
            let pColor = baseColor; 
            let pAlpha = 1.0; 
            let pSize = isMobile ? 1.8 : 1.5; 
            
            if (distFromCenter > 0.8) {
                pColor = "white"; pAlpha = 1.0; 
                pSize *= 1.2;     
                if (Math.random() > 0.7) pColor = highlightColor;
            } else if (distFromCenter < 0.3) { 
                pAlpha = 0.95; 
                pSize *= 0.8;
            }

            treeParticles.push({
                cx: cx, radius: offsetX, baseY: y,         
                size: pSize, baseSize: pSize, color: pColor, 
                alpha: pAlpha, baseAlpha: pAlpha, 
                startAngle: Math.random() * Math.PI * 2, 
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.05
            });
            created++;
        }
    }
    return treeParticles;
}

let leftTree = [];
let rightTree = [];
let treeBaseY; 

function initTrees() {
    treeBaseY = window.innerHeight * 0.88;
    const w = window.innerWidth;
    const offset = isMobile ? 0.20 : 0.25;
    
    leftTree = generateNaturalLayeredTree(w * offset, treeBaseY, "rgba(70, 160, 255, 1.0)", "cyan");
    rightTree = generateNaturalLayeredTree(w * (1-offset), treeBaseY, "rgba(255, 105, 180, 1.0)", "pink");
}

// ================================
// VẼ & ANIMATION
// ================================

function updateAndDrawOrbit(ctx, particles, layer, centerY, flatten, maxZ) {
    const centerX = window.innerWidth / 2;
    const len = particles.length;
    
    ctx.shadowBlur = 0;

    for(let i = 0; i < len; i++) {
        const p = particles[i];
        if (layer === 'back' || layer === 'all') { p.angle += p.orbitSpeed; }
        
        const relativeZ = p.orbitRadius * Math.sin(p.angle);
        
        if (layer === 'back' && relativeZ >= 0) continue;
        if (layer === 'front' && relativeZ < 0) continue;

        const relativeX = p.orbitRadius * Math.cos(p.angle);
        const perspectiveY = relativeZ * flatten; 
        const zNorm = relativeZ / maxZ;
        const scaleFactor = 1 + zNorm * 0.7;

        p.x = centerX + relativeX;
        p.y = centerY + perspectiveY + p.yOffset; 
        
        // Hạt tuyết nhỏ và sắc nét
        p.size = Math.max(0.4, p.baseSize * scaleFactor);
        p.alpha = Math.max(0.3, Math.min(1, p.baseAlpha * (1 + zNorm * 0.3)));
        
        p.draw(ctx);
    }
}

function drawTree(ctx, treeParticles, time, rotationSpeed) {
    const len = treeParticles.length;
    
    for(let i=0; i<len; i++) {
        const p = treeParticles[i];
        const currentAngle = p.startAngle + time * rotationSpeed;
        
        const cosA = Math.cos(currentAngle);
        const sinA = Math.sin(currentAngle);
        
        const relativeX = p.radius * cosA;
        const relativeZ = p.radius * sinA;
        
        const scaleFactor = 1 + (relativeZ / (isMobile?120:180)) * 0.5;
        const windY = (noise(p.cx, p.baseY, time * 0.8) - 0.5) * 3;
        
        p.x = p.cx + relativeX;
        p.y = p.baseY + windY;
        p.size = p.baseSize * scaleFactor;
        
        ctx.fillStyle = p.color;
        
        if (scaleFactor > 0.8 && (p.color === "white" || p.color === "cyan" || p.color === "pink")) {
             ctx.shadowBlur = (isMobile ? 12 : 15) * scaleFactor;
             ctx.shadowColor = p.color;
             ctx.globalAlpha = 1.0;
        } else {
             ctx.shadowBlur = 0;
             ctx.globalAlpha = 0.98;
        }
        
        ctx.beginPath();
        // Hạt cây luôn dùng arc để đẹp
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.shadowBlur = 0;
}

function drawGlowingStar(ctx, x, y, color, angle) {
    ctx.save(); ctx.translate(x, y);
    const rotate3D = Math.cos(angle);
    const scale = isMobile ? 2.5 : 1.5; 
    ctx.scale(scale * rotate3D, scale); 
    
    ctx.shadowBlur = 25; ctx.shadowColor = color; ctx.fillStyle = color;
    
    ctx.beginPath();
    const spikes = 5; const outerRadius = 15; const innerRadius = 7;
    let rot = Math.PI / 2 * 3; let x_coord = 0; let y_coord = 0;
    const step = Math.PI / spikes;
    ctx.moveTo(0, 0 - outerRadius);
    for (let i = 0; i < spikes; i++) {
        x_coord = Math.cos(rot) * outerRadius; y_coord = Math.sin(rot) * outerRadius;
        ctx.lineTo(x_coord, y_coord); rot += step;
        x_coord = Math.cos(rot) * innerRadius; y_coord = Math.sin(rot) * innerRadius;
        ctx.lineTo(x_coord, y_coord); rot += step;
    }
    ctx.lineTo(0, 0 - outerRadius); ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 10; ctx.fillStyle = "white"; ctx.fill();
    ctx.restore();
}

function drawGlowingMoon(ctx, x, y, color, angle) {
    ctx.save(); ctx.translate(x, y);
    const rotate3D = Math.cos(angle);
    const scale = isMobile ? 2.5 : 1.5;
    ctx.scale(scale * rotate3D, scale); 
    
    ctx.shadowBlur = 25; ctx.shadowColor = color; ctx.fillStyle = color;
    
    ctx.beginPath();
    ctx.arc(0, 0, 15, 0.5 * Math.PI, 1.5 * Math.PI, true);
    ctx.bezierCurveTo(10, -12, 10, 12, 0, 15);
    ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 10; ctx.fillStyle = "white"; ctx.fill();
    ctx.restore();
}

// KHỞI TẠO
createOrbitSnow();
initGroundLayers();
initTrees();

let time = 0;
function animate() {
    time += 0.01;
    
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    
    const gradient = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
    gradient.addColorStop(0, "#000011"); gradient.addColorStop(1, "#1a0b2e");
    ctx.fillStyle = gradient; ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    const snowCenterY = window.innerHeight * 0.5; 
    const groundCenterY = window.innerHeight * 0.88; 
    const flatten = 0.15;
    const maxZ = window.innerWidth * 1.8; 

    // --- LỚP SAU ---
    updateAndDrawOrbit(ctx, snowParticles, 'back', snowCenterY, flatten, maxZ);
    updateAndDrawOrbit(ctx, groundOuter, 'back', groundCenterY, flatten, maxZ);
    updateAndDrawOrbit(ctx, groundMiddle, 'back', groundCenterY, flatten, maxZ);
    updateAndDrawOrbit(ctx, groundInner, 'all', groundCenterY, flatten, maxZ);

    // --- LỚP GIỮA (Cây) ---
    const treeRotationSpeed = 0.5; 
    drawTree(ctx, leftTree, time, treeRotationSpeed);
    drawTree(ctx, rightTree, time, -treeRotationSpeed);
    
    const treeTopY = treeBaseY - currentTreeHeight;
    const topperY = treeTopY - (isMobile ? 40 : 60); 
    const offset = isMobile ? 0.20 : 0.25;
    const leftTreeAngle = time * treeRotationSpeed;
    const rightTreeAngle = time * -treeRotationSpeed;

    drawGlowingStar(ctx, window.innerWidth * offset, topperY + Math.sin(time*2)*2, "cyan", leftTreeAngle);
    drawGlowingMoon(ctx, window.innerWidth * (1-offset), topperY + Math.cos(time*2)*2, "pink", rightTreeAngle);

    // --- LỚP TRƯỚC ---
    updateAndDrawOrbit(ctx, groundMiddle, 'front', groundCenterY, flatten, maxZ);
    updateAndDrawOrbit(ctx, groundOuter, 'front', groundCenterY, flatten, maxZ);
    updateAndDrawOrbit(ctx, snowParticles, 'front', snowCenterY, flatten, maxZ);

    requestAnimationFrame(animate);
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        resizeCanvas();
        createOrbitSnow();
        initGroundLayers();
        initTrees();
    }, 200);
});

animate();
</script>
</body>
</html>